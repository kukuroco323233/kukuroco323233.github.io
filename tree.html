<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Christmas Tree Ultra</title>
<style>
body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(circle at top, #2b1200, #000);
}
h1 {
    position: absolute;
    top: 12px;
    width: 100%;
    text-align: center;
    color: #ffd27d;
    letter-spacing: 6px;
    font-weight: 300;
    text-shadow: 0 0 25px #ffcc66;
    z-index: 10;
    pointer-events: none;
}
</style>
</head>
<body>

<h1>MERRY CHRISTMAS</h1>

<!-- IMPORT MAP -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x120700, 300, 900);

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 2000);
camera.position.set(0, 160, 480);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ================= POST PROCESS ================= */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    1.3,
    0.65,
    0.15
);
composer.addPass(bloomPass);

/* ================= CONTROLS ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 240;
controls.maxDistance = 850;
controls.target.set(0, 80, 0);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffe0b3, 0.35));

const warmLight = new THREE.PointLight(0xffb347, 1.5, 900);
warmLight.position.set(250, 350, 200);
scene.add(warmLight);

/* =================================================
   ðŸŒ² TREE PARTICLE
================================================= */
const tree = new THREE.Group();
scene.add(tree);

const count = 2600;
const pos = [];
const col = [];
const size = [];

const palette = [
    "#ffd27d", "#ffb347", "#ffcc66", "#ffae42",
    "#ffe4a1", "#ffc1a1", "#ff9f80",
    "#c94b4b", "#b23a48", "#a94442"
];

for (let i = 0; i < count; i++) {
    const y = Math.random() * 360;
    const r = (1 - y / 360) * 160;
    const a = Math.random() * Math.PI * 2;
    const d = Math.random() * r;

    pos.push(Math.cos(a) * d, y - 180, Math.sin(a) * d);

    const c = new THREE.Color(palette[Math.random() * palette.length | 0]);
    col.push(c.r, c.g, c.b);

    size.push(Math.random() * 5 + 3);
}

const treeGeo = new THREE.BufferGeometry();
treeGeo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
treeGeo.setAttribute("color", new THREE.Float32BufferAttribute(col, 3));
treeGeo.setAttribute("size", new THREE.Float32BufferAttribute(size, 1));

const treeMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    vertexColors: true,
    uniforms: { time: { value: 0 } },
    vertexShader: `
        attribute float size;
        uniform float time;
        varying vec3 vColor;
        void main(){
            vColor = color;
            float pulse = sin(time * 1.5 + position.y * 0.15 + position.x * 0.1)
                          * 0.5 + 1.8;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * pulse * (300.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
        }
    `,
    fragmentShader: `
        varying vec3 vColor;
        void main(){
            float d = distance(gl_PointCoord, vec2(0.5));
            float a = 1.0 - smoothstep(0.25, 0.5, d);
            gl_FragColor = vec4(vColor, a);
        }
    `
});

tree.add(new THREE.Points(treeGeo, treeMat));

/* =================================================
   ðŸŒ€ GARLAND
================================================= */
const gPos = [];
const gCol = [];
for (let i = 0; i < 520; i++) {
    const y = i * 0.7 - 180;
    const r = (1 - i / 520) * 140;
    const a = i * 0.35;
    gPos.push(Math.cos(a) * r, y, Math.sin(a) * r);
    gCol.push(1.0, 0.85, 0.6);
}

const garlandGeo = new THREE.BufferGeometry();
garlandGeo.setAttribute("position", new THREE.Float32BufferAttribute(gPos, 3));
garlandGeo.setAttribute("color", new THREE.Float32BufferAttribute(gCol, 3));

tree.add(new THREE.Points(
    garlandGeo,
    new THREE.PointsMaterial({
        size: 4,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending
    })
));

/* =================================================
   ðŸŽ„ ORNAMENT BALLS
================================================= */
const ballGeo = new THREE.SphereGeometry(4, 16, 16);
for (let i = 0; i < 40; i++) {
    const mat = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
        metalness: 0.8,
        roughness: 0.25
    });
    const ball = new THREE.Mesh(ballGeo, mat);

    const y = Math.random() * 300 - 150;
    const r = (1 - (y + 150) / 300) * 130;
    const a = Math.random() * Math.PI * 2;

    ball.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
    tree.add(ball);
}

/* =================================================
   â­ STAR
================================================= */
function starShape() {
    const s = new THREE.Shape();
    const spikes = 5, o = 8, i = 3.5;
    let a = -Math.PI / 2;
    const step = Math.PI / spikes;

    s.moveTo(Math.cos(a) * o, Math.sin(a) * o);
    for (let k = 0; k < spikes; k++) {
        a += step;
        s.lineTo(Math.cos(a) * i, Math.sin(a) * i);
        a += step;
        s.lineTo(Math.cos(a) * o, Math.sin(a) * o);
    }
    return s;
}

const star = new THREE.Mesh(
    new THREE.ExtrudeGeometry(starShape(), {
        depth: 2,
        bevelEnabled: true,
        bevelSize: 0.8,
        bevelThickness: 0.6
    }),
    new THREE.MeshStandardMaterial({
        color: 0xffd700,
        emissive: 0xffc94d,
        emissiveIntensity: 1.6,
        metalness: 0.6,
        roughness: 0.25
    })
);
star.position.set(0, 200, 0);
scene.add(star);

const starLight = new THREE.PointLight(0xffd27d, 3, 500);
starLight.position.copy(star.position);
scene.add(starLight);

/* =================================================
   â„ï¸ SNOW
================================================= */
const sPos = [];
for (let i = 0; i < 2000; i++) {
    sPos.push(
        (Math.random() - 0.5) * 1000,
        Math.random() * 600,
        (Math.random() - 0.5) * 1000
    );
}

const snowGeo = new THREE.BufferGeometry();
snowGeo.setAttribute("position", new THREE.Float32BufferAttribute(sPos, 3));

const snow = new THREE.Points(
    snowGeo,
    new THREE.PointsMaterial({
        color: 0xfff1d6,
        size: 2,
        transparent: true,
        opacity: 0.8
    })
);
scene.add(snow);

/* ================= RESIZE ================= */
addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
});

/* ================= ANIMATE ================= */
function animate(t) {
    requestAnimationFrame(animate);
    treeMat.uniforms.time.value = t * 0.002;

    tree.rotation.y += 0.0012;
    star.rotation.z += 0.01;

    star.material.emissiveIntensity =
        1.6 + Math.sin(t * 0.004) * 0.6;
    starLight.intensity =
        2.5 + Math.sin(t * 0.004) * 1.2;

    const p = snow.geometry.attributes.position;
    for (let i = 0; i < p.count; i++) {
        p.array[i * 3 + 1] -= 0.6;
        if (p.array[i * 3 + 1] < -200) p.array[i * 3 + 1] = 400;
    }
    p.needsUpdate = true;

    controls.update();
    composer.render();
}

animate();
</script>

</body>
</html>
